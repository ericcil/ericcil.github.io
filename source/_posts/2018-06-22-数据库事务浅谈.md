---
title: 数据库事务浅谈
date: 2018-06-22 08:05:34
tags: 事务
category: 数据库
---

###


<!-- more -->

###事务特性
1. 原子性（Atomicity 
2. 一致性（Consistency 主要指的是数据应该满足完整性约束
3. 隔离性（Isolation 
4. 持久性（Durability 

###数据库读现象
1. **脏读**：指的是无效数据的读取，例如在事务T1修改a的值，尚未提交，事务T2读取了修改后的a值，之后T1撤销对a值的修改，那么T2读取的a值即为无效值

2. **不可重读读**：指一个事务范围内两次相同的查询返回了不同数据。例如事务T1读取a值，T1未结束，此时T2修改了a值，之后T1重新获取a值，就得到了不同的数据。

3. **幻读**：指多次读取一个范围内的记录, 发现结果不一致。例如事务T1首次读取t表数据时，事务T2进行insert操作，T1第二次读取t表数据时得到的结果和第一次查询不同


###MySql中的锁
- **按范围类型可以分为**
    1. 行级锁：是MySql中粒度最细的锁。分为。
        特点是：开销大、加锁慢，会出现死锁，并发度最高
    2. 表级锁：MySql中粒度最大的锁。
        特点是：开销小、加锁快，不会出现死锁，冲突概率高
    3. 页级锁：介于行锁和表锁之间的折中方案

- **按锁共享性质可以分为**
    1. 共享锁（Share Lock）：简称S锁，又名读锁。该锁允许多个事务共享，但是只能做读取操作，期间其他事务不能获取该数据的排它锁，知道释放所有共享锁。
    用法
    ```sql
    select ... lock in share mode;
    ```
    2. 排它锁（eXclusive Lock）：简称X锁，又称写锁。该锁同时只能允许一个事务拥有，期间其他事务无法获取对应数据的排它锁和共享锁
    用法
    ```sql
    select ... for update;
    ```

- **Innodb中的锁**
Innodb支持行级锁和表级锁，默认使用行级锁
Innodb行级锁的实现是 ***通过给索引项加锁实现***。意味着只有通过索引条件检索才能使用行级锁，否则使用表锁。
另外，当在UPDATE、DELETE操作时，MySQL不仅锁定WHERE条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓的next-key locking，当两个事务同时执行，一个锁住了逐渐索引在等待其他相关索引，一个锁定了非主键索引，在等待主键索引。这样就会发生死锁。
发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务。


###悲观锁和乐观锁
悲观锁和乐观锁都属于并发控制的技术手段，是一种思想。
- **悲观锁**
    悲观并发控制（Pessimistic Concurrency Control，缩写“PCC”）。该控制方式始终对数据修改保持悲观态度，认为数据修改一定会发生并发冲突，因此在整个数据处理过程中，始终将数据进行锁定。实现上往往依赖于数据库提供的锁机制
    ***悲观锁主要用于数据争用激烈的环境，以及使用锁的成本比回滚事务成本要低的环境***

悲观锁实现：
>对数据修改前，为该数据加上排它锁<br>
如果加锁成功，则可以进行数据修改，事务完成后进行锁释放。<br>
如果加锁失败,则证明有其他事务正在操作，可以进行所等待或者其他操作


- **乐观锁**
    乐观并发控制（Optimistic Concurrency Control，缩写“OCC”）。该控制方法对数据的修改保持乐观态度，假设并发的事务一般情况下不会互相影响。只在提交数据更新时对数据进行冲突校验，保证没有其他事务操作同一数据。
    ***乐观锁适用于数据争用没有那么激烈的情况***

乐观锁实现：
>通常情况下使用数据版本号作为判断标识，读取数据时获取版本标识，更新数据时对版本标识进行校验，并且加一。<br>
如果提交修改时，提交的版本号与数据库里记录的版本号不一致。则认为有冲突，采取其他恰当操作。
