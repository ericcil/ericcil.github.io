---
title: 重复请求的处理
date: 2018-03-01 22:35:47
tags:
category: 工作实践
---

###


<!-- more -->

&emsp;&emsp;目前的项目中偶尔会出现前端html在很短的时间内（1s以内）请求多次后台接口的情况，这造成了后台存在部分异常数据。其中前端html肯定是存在问题的，但是后台也存在相应的问题。如在接收前端数据提交时（如POPST,PUT）重复插入数据，重复修改同一条数据。这其中牵扯到后台对重复请求的处理。这里就根据这段时间遇到的问题场景，针对重复请求问题谈一谈幂等性。
&emsp;&emsp;最简单的一种重复请求场景是查询（如GET），查询请求由于不涉及到对数据的修改操作，所以只有查询功能的接口，本身就具备幂等性，无论请求几次，频率怎样，结果是相同的。
&emsp;&emsp;涉及数据修改的接口，需要根据实际场景来讨论了。例如：
统计接口的调用次数，这种场景下计数器必须是累加的，操作上并不具有幂等性，开发时也无需考虑。
又如：
1.注册场景里，要求用户身份证唯一，提交过一次的身份证不能再提交
2.支付场景中，一个订单只能支付一次，如果成功支付后在发起支付请求，也不能再次支付
以上两个例子都是业务上具有幂等性的操作，在代码实现时需要实现接口的幂等性，这种场景中就无关乎前端的请求有几次，是后台必须考虑幂等性的情况。
&emsp;&emsp;在具有幂等性的操作中必须要有对重复请求的应对方案。
1.在数据库中采用实现幂等性：通过在数据库中加入唯一性约束、根据状态进行有条件修改实现操作的幂等性。
2.在代码中进行请求的去重操作，直到首次请求处理完毕或被迫终止，才接收下次请求。
&emsp;&emsp;这次我在处理系统中重复请求问题时，采用的是第二种方式，因为controller层是有负载的，所以不能使用java原生的同步支持。综合考虑后使用redis提供的hsetnx( redis 还有 setnx 指令提供分布式锁的支持)，在每次接收到请求时，根据当前客户和请求内容生成唯一key存入redis。只有当hsetnx返回成功后才能继续处理请求。存在的问题：setnx和hsetnx不存在生存时间的设置，如果程序被突然中断（如直接杀死进程）时将会堵塞后续请求。
