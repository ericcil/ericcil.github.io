---
title: 设计模式学习（一）
date: 2018-05-10 20:16:34
tags:
category:
---

###

简单记录所学的设计模式，本文简单归纳近期所学的创建模式

<!-- more -->

&emsp;&emsp;创建模式即创建对象的设计模式，为什么创建对象需要模式呢？
- ***一方面来说是为了控制对象的生成***
- ***另一方面来说是为了封装对象的具体创建过***

-----

####常见的创建模式包含:
- 单例模式 - singleton
- 多例模式 -multition
- 简单工厂模式 - simple factory
- 工厂方法模式 - factory method
- 抽象工厂模式 - abstract factory
- 建造模式 - builder
- 原型模式 - prototype

**按上述创建模式的初衷，可以将这些设计模式划分为两类：**

1. 控制对象生成的模式：单例、多例模式
2. 封装具体创建过程的模式：工厂、建造和原型模式 

****

###1. 单例模式
单例模式便是控制对象在系统中只有一个实例。***实现的方式就是将类的构造方式私有化，由内部提供一个获取唯一实例的公有静态方法。*** 除了该类之外的其他类无法通过此方法之外的其他手段创建该类实例，从而保证该类在系统中只有一个实例。
以java为例

```java
//饿汉单例的例子
public class Sample{

    //持有自身实例
    private static Sample instance = new Sample();
    //私有化构造
    private Sample(){}
    //返回实例的静态方法
    public static Sample getInstance(){
        return instance;
    }
}
```

单例的实现基础就是上述的两点，不过针对实例的产生时间又可具体分为 
1. ***饿汉单例*** ：类定义时就赋予一个实例，上面的例子即为饿汉模式
2. ***懒汉单例*** ：在实际调用该类时才在没有实例的情况下创建实例

对于懒汉模式，由于实例的创建被推迟到使用单例类的时候，就有可能在多线程情况下出现 **并发访问**，从而同时生成多个实例，破坏了原有的设计。所以实现上都会使用锁进行控制。如：

```java
//使用同步实现懒汉单例的例子
public class Sample{

    private static Sample instance;
    private Sample(){}
    //加上同步关键字，保证线程安全
    public synchronized static Sample getInstance(){
        if(instance == null){
            instance = new Sample();
        }
        return instance;
    }
}
```

在并发情况下还有一种 ***双重检查*** 的思路，由于在方法上加入同步关键字之后，对该方法的调用，都会对该类进行锁请求和释放操作，这时肯定会比不加锁的情况要更加耗时，尤其是在需要大量使用单例类的情况。

```java
//双重检查
public class Sample{

    private static Sample instance;
    private Sample(){}
    //加上同步关键字，保证线程安全
    public static Sample getInstance(){
        //首次判断
        if(instance == null){
            //同步
            synchronized(Sample.class){
                //第二次判断
                if(instance == null){
                    instance = new Sample();
                }
            }
        }
        return instance;
    }
}
```
双重检查提供了一种降低锁请求次数的思路
####<font color="#dd0000">需要注意的是：</font>
***《java与模式》一书中（第232页）表明，在java语言中这是一种错误的语法***
我在本地测试的结果是并没有报任何异常
关于在java中双重检查的有效性还需要考察

***针对于java，还有一种更好的，利用java特性实现懒汉单例的方式，即依靠内部类的加载来实现。***

